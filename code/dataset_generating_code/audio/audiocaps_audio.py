# -*- coding: utf-8 -*-
"""testing katna.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iEcCju8-iXb4UpE4mO-947R3tsamawby
"""


import pandas as pd
import json

def clean_data_labels(data_path, label_json_path, output_path = None):
  def cleaning(label):
    label = label.replace('"', '').replace(' ', '')
    return ';'.join([id_label_map[i] for i in label.split(';')])

  df = pd.read_csv(data_path)

  with open(label_json_path, 'r') as file:
      data = json.load(file)

  id_label_map = {dictionary['id'] : dictionary['name'] for dictionary in data}

  df['positive_labels'] = df[' positive_labels'].apply(cleaning)

  if output_path:
    df.to_csv(output_path)
  return df

#df = clean_data_labels('eval_segments_reg_clean.csv', 'ontology.json')
df = pd.read_csv('train.csv')

timestamps = {row['youtube_id']: row['start_time'] for i, row in df.iterrows()}

def cleaning(label):
  label = label.replace('"', '').replace(' ', '')
  return ';'.join([clean[i] for i in label.split(';')])


import pandas as pd
from yt_dlp import YoutubeDL
from bs4 import BeautifulSoup

YOUTUBE_URL_PREFIX = "https://www.youtube.com/watch?v="

def download_video(video_url,i):
    opts = {'paths': {'home': f'downloads{i}'}}
    with YoutubeDL(opts) as yt:
        yt.download(video_url)
def download_column(yt_ids, i, stop=None):
    # If stop is None, set it to the length of yt_ids
    stop = len(yt_ids) if stop is None else stop

    # Iterate through the specified number of items
    sum = 0
    for yt_id in yt_ids[:stop]:
      try:  
        download_video(YOUTUBE_URL_PREFIX + yt_id, i)
      except Exception as e:
        sum+=1
        continue
    return sum

from moviepy.video.io.ffmpeg_tools import ffmpeg_extract_subclip
#ffmpeg_extract_subclip("/content/Vehicle Alignments [--BfvyPmVMo].mp4", 0, 10, 'downloads0/test.mp4')

'''from Katna.video import Video
from Katna.writer import KeyFrameDiskWriter
import os

# For windows, the below if condition is must.
if __name__ == "__main__":

  # initialize video module
  vd = Video()

  # number of images to be returned
  no_of_frames_to_returned = 10

  # initialize diskwriter to save data at desired location
  diskwriter = KeyFrameDiskWriter(location="selectedframes")

  # Video file path
  video_file_path = "/content/downloads/VELHO DA TOSSE.wmv [--U7joUcTCo].mp4"

  print(f"Input video file path = {video_file_path}")

  # extract keyframes and process data with diskwriter
  vd.extract_video_keyframes(
       no_of_frames=no_of_frames_to_returned, file_path=video_file_path,
       writer=diskwriter
  )
'''

import subprocess

def get_clips2(yt_ids, id):
  filenames = [file for file in os.listdir(f'downloads{id}')]
  title_to_id = {filename : extract_youtube_ids(filename) for filename in filenames}
  for filename in filenames:
    root, extension = os.path.splitext(filename)
    video_id = title_to_id[filename]
    command = ['ffmpeg',
               '-i', f'downloads{id}/{filename}',
               '-ss', str(timestamps[video_id]),
               '-to', str(timestamps[video_id] + 10),
               '-c', 'copy',
               f'downloads{id}/{root}_cut{extension}'
    ]
    subprocess.run(command)
    os.remove(f"downloads{id}/{filename}")

def get_audio(id):
  for filename in os.listdir(f'downloads{id}'):
    root, extension = os.path.splitext(filename)

    command = [
      'ffmpeg',
      '-i', f'downloads{id}/{filename}',  # Input file
      '-q:a', '0',  # Video filter: scale to 720p
      '-map', 'a',
      f'audiocaps_train/{root}.wav'  # Output file
    ]

    subprocess.run(command)

import re

def extract_youtube_ids(filename):
    """
    Extracts YouTube video IDs from a list of filenames.

    Args:
        filenames (list of str): List of filenames containing YouTube IDs.

    Returns:
        list of str: Extracted YouTube IDs.
    """
    pattern = r'\[([-_\w]{11})\]'  # Matches square brackets with 11-character YouTube IDs

    match = re.search(pattern, filename)
    if match:
      return (match.group(1))
    return ''

import os

def get_clips(yt_ids, id):
  filenames = [file for file in os.listdir(f'downloads{id}')]
  title_to_id = {filename : extract_youtube_ids(filename) for filename in filenames}
  for filename in filenames:
    root, extension = os.path.splitext(filename)
    video_id = title_to_id[filename]
    ffmpeg_extract_subclip(f'downloads{id}/{filename}', timestamps[video_id][0], timestamps[video_id][1], f'downloads{id}/{root}_cut{extension}')
    os.remove(f"downloads{id}/{filename}")

from Katna.video import Video
from Katna.writer import KeyFrameDiskWriter

def get_frames(id):
  vd = Video()

  # number of images to be returned
  no_of_frames_to_returned = 1

  # initialize diskwriter to save data at desired location
  diskwriter = KeyFrameDiskWriter(location=f"frames{id}")

  for filename in os.listdir(f'downloads{id}'):

    # Video file path
    video_file_path = f"downloads{id}/{filename}"

  # extract keyframes and process data with diskwriter
    vd.extract_video_keyframes(
        no_of_frames=no_of_frames_to_returned, file_path=video_file_path,
        writer=diskwriter
    )

import os
import pandas as pd
import numpy as np

# Example DataFrame


# Number of chunks
n_chunks = 100

# Split into chunks
temp = df.iloc[1000:1500]
chunks = np.array_split(temp, n_chunks)


def process_chunck(df, id):
    yt_ids = df['youtube_id']
    errors = download_column(yt_ids, id)
    get_clips2(yt_ids, id)
    get_audio(id)
    command = ['rm', '-r', f'downloads{id}']
    subprocess.run(command)
    return errors


# Each chunk is a DataFrame
sum = 0
for i, chunk in enumerate(chunks):
  sum = sum + process_chunck(chunk, i)

print("errors")
print(sum)
